Knowledge Transfer

Pre-trained distillation

mooshine transparent-computing

train by different modules (file, process, ...)

------



## analyze

1. Fuzzing is to generate a unexpected syscall sequence to hit a problem scenario which developer did not find. So a reasonable/make sence sequence may not be efficient? 
   1. follow up: what about insert some random calls into a reasonable sequence?
2. Sequence generated by LLM may could be produced in advance rather than in run time. May the later doesn't make any sence.

## setup env

> [link1](https://snappyjack.github.io/articles/2020-05/%E4%BD%BF%E7%94%A8Syzkaller%E8%BF%9B%E8%A1%8C%E5%86%85%E6%A0%B8fuzz): install dependencies;
>
> [link2](https://m.freebuf.com/vuls/322630.html): set .config;
>
> [link3](https://github.com/google/syzkaller/blob/master/docs/linux/troubleshooting.md): "Failed to start Raise network interfaces"

## syzkaller

### overview

- sys-executor receives inputs generated by syz-fuzzer (syscalls), runs them, and returns results.

![img](../assets/ad-1.png)



### Syscall description language

> [official guide](https://github.com/google/syzkaller/blob/master/docs/syscall_descriptions_syntax.md)
>
> [sample](https://github.com/google/syzkaller/blob/master/sys/linux/sys.txt)

use to manipulate the syscall sequence of fuzz.

Process:

.txt (description file) ---syz-extract--> .const



Sytax

```
syscall$tested_module(para_name1 para_type[values], ...) return value

e.g. :
open$testxy(file ptr[in, string["/proc/test1"]], flags flags[proc_open_flags], mode flags[proc_open_mode]) fd

read$testxy(fd fd, buf buffer[out], count len[buf]) len[buf]

write$testxy(fd fd, buf buffer[in], count len[buf]) len[buf]

proc_open_flags = O_RDONLY, O_WRONLY, O_RDWR, O_APPEND, FASYNC, O_CLOEXEC, O_CREAT, O_DIRECT, O_DIRECTORY, O_EXCL, O_LARGEFILE, O_NOATIME, O_NOCTTY, O_NOFOLLOW, O_NONBLOCK, O_PATH, O_SYNC, O_TRUNC, __O_TMPFILE

proc_open_mode = S_IRUSR, S_IWUSR, S_IXUSR, S_IRGRP, S_IWGRP, S_IXGRP, S_IROTH, S_IWOTH, S_IXOTH
```



Usually a device node corresponds to a description file



### An example: add a module to target kernel and create crashes

#### 1. check syz-extract and syz-sysgen exist in syzkaller/bin

if not, run

```
make bin/syz-extract
make bin/syz-sysgen
```



#### 2. add and compile new module

1. create file in linux/drivers/char

   ```
   #include <linux/init.h>
   #include <linux/module.h>
   #include <linux/proc_fs.h>
   #include <linux/uaccess.h>
   #include <linux/slab.h>
   
   
   static int proc_open (struct inode *proc_inode, struct file *proc_file)
   {
       printk(":into open!\n");
       return 0;
   }
   
   static ssize_t proc_read (struct file *proc_file, char __user *proc_user, size_t n, loff_t *loff)
   {
       printk(":into read");
       return 0;
   }
   
   static ssize_t proc_write (struct file *proc_file, const char __user *proc_user, size_t n, loff_t *loff)
   {
       char *c = kmalloc(512, GFP_KERNEL);
       copy_from_user(c, proc_user, 4096);
       printk(":into write!\n");
       return 0;
   }
   
   static struct proc_ops test_op = {
       .proc_open = proc_open,
       .proc_read = proc_read,
       .proc_write = proc_write,
   };
   
   static int __init mod_init(void)
   {
       proc_create("test1", S_IRUGO|S_IWUGO, NULL, &test_op);
       printk(":proc init over!\n");
       return 0;
   }
   
   module_init(mod_init);
   ```

   

2. vim char/KCconfig

   ```
   config TESTXY_MODULE
           tristate "heap overflow test"
           default y
           help
             This file is to test a buffer overflow
   ```



3. vim char/Makefile

   ```
   obj-$(CONFIG_TESTXY_MODULE) += testxy.o
   ```



4. re-compile kernel

   ```
   make clean
   make -j4
   ```

   

   check `Device Drivers -> Heap Overflow Test`

   ```
   make menuconfig
   ```



5. check added module in VM

   ```
   # check if exist
   ls /proc/test1
   # check load info
   dmesg | grep "proc init"
   ```

   

#### 3. customize description for new added module

1. add new file to syzkaller/sys/linux/proc_testxy.txt

   ```
   include <linux/fs.h>
   
   open$testxy(file ptr[in, string["/proc/test1"]], flags flags[proc_open_flags], mode flags[proc_open_mode]) fd
   read$testxy(fd fd, buf buffer[out], count len[buf]) len[buf]
   write$testxy(fd fd, buf buffer[in], count len[buf]) len[buf]
   
   proc_open_flags = O_RDONLY, O_WRONLY, O_RDWR, O_APPEND, FASYNC, O_CLOEXEC, O_CREAT, O_DIRECT, O_DIRECTORY, O_EXCL, O_LARGEFILE, O_NOATIME, O_NOCTTY, O_NOFOLLOW, O_NONBLOCK, O_PATH, O_SYNC, O_TRUNC, __O_TMPFILE
   proc_open_mode = S_IRUSR, S_IWUSR, S_IXUSR, S_IRGRP, S_IWGRP, S_IXGRP, S_IROTH, S_IWOTH, S_IXOTH
   ```

   

2. syz-extract -> .const

   gen extract and sysgen if not exist

   ```
   make bin/syz-extract
   make bin/syz-sysgen
   ```

   ```
   bin/syz-extract -os linux -arch amd64 -sourcedir "/home/parallels/fuzz/kernel/linux-5.15.15" proc_testxy.txt
   ```

   

3. re-compile syzkaller

   ```
   make
   ```



4. check .config in syzkaller

   ```
   "enable_syscalls":[
           		"open$testxy",
           		"read$testxy",
           		"write$testxy",
           		"close"
        ],
   ```



5. run VM and syzkaller